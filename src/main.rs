use clap::{Parser, Subcommand};

use crate::cli::VTClient;

mod cli;
mod security;
mod serve;

#[derive(Parser)]
#[command(author, version, about="a simple kms. no plain, explicit auth everywhere")]
struct Cli {
    #[arg(
        long,
        global = true,
        env = "VT_ADDR",
        default_value = "127.0.0.1:5757",
        help = "Host and port in the format host:port, e.g. 127.0.0.1:5757"
    )]
    addr: String,

    #[arg(
        long,
        global = true,
        env = "VT_AUTH",
        default_value = "MY5hkACZQZbqfpuYaWjnzlbpGVQYhwqynnrpkek568g",
        help = "Authorization header value, generated by `vault init` command"
    )]
    auth: String,

    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand, PartialEq)]
enum Commands {
    /// Will read plain text and output encrypted message for you
    Create,
    /// Decrypt an existing vt protocol as plaintext
    Read {
        #[arg(help = "A string in vt protocol format, e.g. vt://mac/0xxxx")]
        vt: String,
    },
    /// Read file and decrypt vt protocol, output to output-file or standard output
    Inject {
        #[arg(short = 'i', long = "input-file", help = "Path to the input file")]
        input_file: Option<String>,

        #[arg(short = 'o', long = "output-file", help = "Path to the output file")]
        output_file: Option<String>,

        #[arg(
            short = 't',
            long,
            default_value = "2",
            help = "Timeout for deleting output_file after the spawned process in seconds"
        )]
        timeout: u32,

        #[arg(
            trailing_var_arg = true,
            help = "Additional arguments to pass to the spawned process"
        )]
        args: Vec<String>,
    },

    #[cfg(target_os = "macos")]
    /// (Mac only) Run vt server
    Serve,
    /// (Mac only) Initialize passcode, passphrase which will be used by server
    #[cfg(target_os = "macos")]
    Init,
    /// (Mac only) Manage master secret
    #[cfg(target_os = "macos")]
    #[command(subcommand)]
    Secret(SecretCommands),
}

#[cfg(target_os = "macos")]
#[derive(Subcommand, PartialEq)]
pub enum SecretCommands {
    /// Export the encrypted master secret
    Export,
    /// Import an encrypted master secret
    Import,
    /// Rotate the passcode for the master secret
    RotatePasscode {
        #[arg(long, help = "Absolute path to the new vt binary")]
        bin_absolute_path: Option<String>,
    },
}

#[tokio::main]
async fn main() {
    let log_level = std::env::var("RUST_LOG")
        .unwrap_or_else(|_| {
            if cfg!(debug_assertions) {
                "debug".to_string()
            } else {
                "info".to_string()
            }
        })
        .parse::<tracing::Level>()
        .unwrap_or(tracing::Level::INFO);
    tracing_subscriber::fmt()
        .with_max_level(log_level)
        .with_target(true)
        .with_line_number(true)
        .compact()
        .init();
    let cli = Cli::parse();

    let command_result = match &cli.command {
        #[cfg(target_os = "macos")]
        Commands::Serve | Commands::Init => match &cli.command {
            Commands::Serve => serve::serve(&cli.addr).await,
            Commands::Init => cli::init(),
            _ => unreachable!(),
        },
        #[cfg(target_os = "macos")]
        Commands::Secret(secret_command) => match secret_command {
            SecretCommands::Export => cli::export_secret().await,
            SecretCommands::Import => cli::import_secret().await,
            SecretCommands::RotatePasscode { bin_absolute_path } => {
                cli::rotate_passcode(bin_absolute_path.clone()).await
            }
        },
        Commands::Create => {
            let vt_client = VTClient::new(cli.addr.clone(), cli.auth);
            cli::create(vt_client).await
        }
        Commands::Read { vt } => {
            let vt_client = VTClient::new(cli.addr.clone(), cli.auth);
            cli::read(vt_client, vt.to_string()).await
        }
        Commands::Inject {
            input_file,
            output_file,
            timeout,
            args,
        } => {
            let vt_client = VTClient::new(cli.addr.clone(), cli.auth);
            cli::inject(
                vt_client,
                input_file.clone(),
                output_file.clone(),
                *timeout,
                args.clone(),
            )
            .await
        }
    };
    if command_result.is_err() {
        tracing::error!("Command failed: {:?}", command_result);
        std::process::exit(1);
    }
}
